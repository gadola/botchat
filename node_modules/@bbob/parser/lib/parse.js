"use strict";

exports.__esModule = true;
exports["default"] = exports.parse = void 0;

var _TagNode = _interopRequireDefault(require("@bbob/plugin-helper/lib/TagNode"));

var _lexer = require("./lexer");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @public
 * @param {String} input
 * @param {Object} opts
 * @param {Function} opts.createTokenizer
 * @param {Array<string>} opts.onlyAllowTags
 * @param {String} opts.openTag
 * @param {String} opts.closeTag
 * @param {Boolean} opts.enableEscapeTags
 * @return {Array}
 */
var parse = function parse(input, opts) {
  if (opts === void 0) {
    opts = {};
  }

  var options = opts;
  var tokenizer = null;
  /**
   * Result AST of nodes
   * @private
   * @type {ItemList}
   */

  var nodes = (0, _utils.createList)();
  /**
   * Temp buffer of nodes that's nested to another node
   * @private
   * @type {ItemList}
   */

  var nestedNodes = (0, _utils.createList)();
  /**
   * Temp buffer of nodes [tag..]...[/tag]
   * @private
   * @type {ItemList}
   */

  var tagNodes = (0, _utils.createList)();
  /**
   * Temp buffer of tag attributes
   * @private
   * @type {ItemList}
   */

  var tagNodesAttrName = (0, _utils.createList)();
  /**
   * Cache for nested tags checks
   * @type {{}}
   */

  var nestedTagsMap = {};

  var isTokenNested = function isTokenNested(token) {
    if (typeof nestedTagsMap[token.getValue()] === 'undefined') {
      nestedTagsMap[token.getValue()] = tokenizer.isTokenNested(token);
    }

    return nestedTagsMap[token.getValue()];
  };

  var isTagNested = function isTagNested(tagName) {
    return !!nestedTagsMap[tagName];
  };
  /**
   * Flushes temp tag nodes and its attributes buffers
   * @private
   * @return {Array}
   */


  var flushTagNodes = function flushTagNodes() {
    if (tagNodes.flushLast()) {
      tagNodesAttrName.flushLast();
    }
  };
  /**
   * @private
   * @return {Array}
   */


  var getNodes = function getNodes() {
    var lastNestedNode = nestedNodes.getLast();
    return lastNestedNode ? lastNestedNode.content : nodes.toArray();
  };
  /**
   * @private
   * @param {TagNode} tag
   */


  var appendNodes = function appendNodes(tag) {
    getNodes().push(tag);
  };
  /**
   * @private
   * @param {String} value
   * @return {boolean}
   */


  var isAllowedTag = function isAllowedTag(value) {
    if (options.onlyAllowTags && options.onlyAllowTags.length) {
      return options.onlyAllowTags.indexOf(value) >= 0;
    }

    return true;
  };
  /**
   * @private
   * @param {Token} token
   */


  var handleTagStart = function handleTagStart(token) {
    flushTagNodes();

    var tagNode = _TagNode["default"].create(token.getValue());

    var isNested = isTokenNested(token);
    tagNodes.push(tagNode);

    if (isNested) {
      nestedNodes.push(tagNode);
    } else {
      appendNodes(tagNode);
    }
  };
  /**
   * @private
   * @param {Token} token
   */


  var handleTagEnd = function handleTagEnd(token) {
    flushTagNodes();
    var lastNestedNode = nestedNodes.flushLast();

    if (lastNestedNode) {
      appendNodes(lastNestedNode);
    } else if (options.onError) {
      var tag = token.getValue();
      var line = token.getLine();
      var column = token.getColumn();
      options.onError({
        message: "Inconsistent tag '" + tag + "' on line " + line + " and column " + column,
        tagName: tag,
        lineNumber: line,
        columnNumber: column
      });
    }
  };
  /**
   * @private
   * @param {Token} token
   */


  var handleTag = function handleTag(token) {
    // [tag]
    if (token.isStart()) {
      handleTagStart(token);
    } // [/tag]


    if (token.isEnd()) {
      handleTagEnd(token);
    }
  };
  /**
   * @private
   * @param {Token} token
   */


  var handleNode = function handleNode(token) {
    /**
     * @type {TagNode}
     */
    var lastTagNode = tagNodes.getLast();
    var tokenValue = token.getValue();
    var isNested = isTagNested(token);

    if (lastTagNode) {
      if (token.isAttrName()) {
        tagNodesAttrName.push(tokenValue);
        lastTagNode.attr(tagNodesAttrName.getLast(), '');
      } else if (token.isAttrValue()) {
        var attrName = tagNodesAttrName.getLast();

        if (attrName) {
          lastTagNode.attr(attrName, tokenValue);
          tagNodesAttrName.flushLast();
        } else {
          lastTagNode.attr(tokenValue, tokenValue);
        }
      } else if (token.isText()) {
        if (isNested) {
          lastTagNode.append(tokenValue);
        } else {
          appendNodes(tokenValue);
        }
      } else if (token.isTag()) {
        // if tag is not allowed, just past it as is
        appendNodes(token.toString());
      }
    } else if (token.isText()) {
      appendNodes(tokenValue);
    } else if (token.isTag()) {
      // if tag is not allowed, just past it as is
      appendNodes(token.toString());
    }
  };
  /**
   * @private
   * @param {Token} token
   */


  var onToken = function onToken(token) {
    if (token.isTag() && isAllowedTag(token.getName())) {
      handleTag(token);
    } else {
      handleNode(token);
    }
  };

  tokenizer = (opts.createTokenizer ? opts.createTokenizer : _lexer.createLexer)(input, {
    onToken: onToken,
    onlyAllowTags: options.onlyAllowTags,
    openTag: options.openTag,
    closeTag: options.closeTag,
    enableEscapeTags: options.enableEscapeTags
  }); // eslint-disable-next-line no-unused-vars

  var tokens = tokenizer.tokenize();
  return nodes.toArray();
};

exports.parse = parse;
var _default = parse;
exports["default"] = _default;